// Module: Utilities
// History:
//  Feb 2017  - JMJ created.
import java.util.NoSuchElementException;
import java.util.Locale;

// NOTE: we're not making CommonUtils a static class so that we can call Processing's numerous methods if needed.
// Downside is that you need an instance to use it. This global instance is typically called gUtils.
public class CommonUtils {
    private final String HEADING_IN = "IN"; // Info-tableheading
    private final String HEADING_SOL = "SOLUTION"; // Info-table heading.

  // Generates a media filename stub given puzzle type and 0-based index of puzzle index.
  // Example: genMediaFileNameStub("clocks", "01" ) produces "output/EN/clocks/clocks-01"
  // If IN is null or empty the -<IN> is omitted.
  public  String genMediaFilenameStub(String puzzleType, String IN) {
    String suffix = "";
    if (IN != null && !IN.isEmpty()) {
      suffix = "-" + IN;
    }
    return "output/" + LANG_VER + "/" + puzzleType + "/" + puzzleType + suffix;
  }

  
  // Creates a table to be used to accumulate info about all instances of a particular type of puzzle.
  // When done it should be saved.
  public Table newInfoTable() {
    Table tab = new Table();
    tab.addColumn(HEADING_IN);
    tab.addColumn(HEADING_SOL);
    return tab;
  }
  
  // Add a puzzle instance to the info-table.
  // IN - solution instance ID.
  // puzzleText - answer (as generated by the puzzle; certain things may be different like spacing and accents.)
  public void addInstanceToTable(Table tab, String IN, String puzzleText) {
    TableRow row = tab.addRow();
    row.setString(HEADING_IN, IN);
    row.setString(HEADING_SOL, puzzleText);
  }
  
  // Save the info table. File name is output/<puzzleType>/<p  uzzleType>-info.csv
  public void saveInfoTable(Table tab, String puzzleType) {
    saveTable(tab, genMediaFilenameStub(puzzleType, null) + "-info.csv");
  }
}

class MasterSolutionList {

  private class Mapping {
    public String id;
    public String sol;
    public String canSol;
    public Mapping(String id, String sol, String canSol) {
      this.id = id;
      this.sol = sol;
      this.canSol = canSol;
    }
    public String toString() {
      return "(" + id + "," + sol + "," + canSol + ")";
    }
  }
  private final String ID_HEADING = "IN";
  private Mapping[] map; // Map of IDs to Solutions. 1st Col are IDs. 
  // 2nd Col is solution. 3rd col is canonicalized soln.      
  // We don't use a dictionary as we want flexibility in finding IDs.
  // filename - CSV file containing the master solutions list.
  // solutionCol - The heading of the column that contains the solution
  public MasterSolutionList(String filename, String solutionCol) {
    Table table = loadTable(filename, "header");
    println("MSL: rowcount: " + table.getRowCount());
    map = new Mapping[table.getRowCount()];
    int i = 0;
    for (TableRow row : table.rows()) {
      int id = row.getInt(ID_HEADING);
      String sol = row.getString(solutionCol);
      map[i] = new Mapping(String.format("%02d", id), sol, canonicalize(sol));
      //println(map[i]);
      i++;
    }
  }


  // Looks up the instance ID corresponding to the supplied solution.
  // This lookup strips out all whitespace and then does a case-insensitive compare.
  // Throws a NotFound exception if it doesn't find anything.
  public String lookupIN(String solution) {
    String canSol = canonicalize(solution);
    println("Looking up " + canSol);
    for (Mapping item : map) {
      if (canSol.equals(item.canSol)) {
        return item.id;
      }
    }
    throw new NoSuchElementException("Unknown solution: " + solution + "/" + canSol);
  }


  private String canonicalize(String s) {
    final char[] accentsMap = "ÚUÁAÍIÉE".toCharArray(); // There are more of course, but these we are dealing with now.
    s = s.replaceAll("\\s", "").toUpperCase();//Locale.ENGLISH);
    // Now replace accents...
    for (int i = 0; i< accentsMap.length; i+=2) {
       s = s.replace(accentsMap[i], accentsMap[i+1]);
    }
    return s;
  }
}